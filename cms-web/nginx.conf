
events {
    worker_connections  1024;#한 프로세스가 동시에 처리할 수 있는 연결 수 정의
	multi_accept	on;#여러 연결을 한번에 수락할 것인지 정의
	accept_mutex	on;#뮤텍스[연결 수락을 조절함]의 사용 여부 결정
	accept_mutex_delay	500ms;#뮤텍스가 동시에 연결을 수락하는 것에 대한 지연시간 설정
}

http {
    include       mime.types;
    default_type  application/octet-stream;
	
    log_format main '$remote_addr - $remote_user [$time_local] '
                                '"$request" '
                                '$status $body_bytes_sent '
                                '"$http_referer" '
                                '"$http_user_agent" '
                                '"$http_x_forwarded_for" '
                                'Host:"$host" '
                                'Request_URI:"$request_uri" '
                                'Query_String:"$query_string" '
                                'Request_Method:"$request_method" '
                                'Protocol:"$server_protocol" '
                                'Content_Length:"$content_length" '
                                'Content_Type:"$content_type" '
                                'Cookies:"$http_cookie" '
                                'Connection:"$connection" '
                                'Connection_Requests:"$connection_requests"';
    access_log  logs/access.log  main;
    error_log logs/error.log info;
	
    sendfile        on;
    
    keepalive_timeout  65;
	
	upstream cms-was {
		server cms-service1:8080;		# tomcat1
		server cms-service2:8080 backup;# tomcat2
		
		check interval=2000 rise=2 fall=2 timeout=500 type=http;
		check_http_send "HEAD /api/v1/com/healthCheck.do HTTP/1.0\r\n\r\n";
		check_http_expect_alive http_2xx http_3xx;
	}
	
    server_tokens off;  # 서버 버전 숨기기
	
    server {
        listen 80;

		underscores_in_headers on;
		
        location / {
			root	/usr/share/nginx/html;
			index index.html;
		}
		location ~ \.do$ {
			proxy_pass	http://cms-was;	#위에서 정의한 upstream의 이름을 여기에 사용
			proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
			proxy_connect_timeout 5s;     # 백엔드 연결 대기 최대 5초
			proxy_send_timeout 5s;       # 요청 전송 10초 제한
			proxy_read_timeout 15s;       # 응답 수신 30초 제한
			
			proxy_set_header	Proxy-Client-IP	$remote_addr;	#server에 전송할 header 세팅
			proxy_set_header X-Hash-Key	$remote_addr;
			proxy_set_header	session_user_id	$http_session_user_id;
			client_max_body_size	0;	#cli에서 전송하는 최대 요청 바이트 크기를 제한함[0은 무제한] <=> maxPostSize
			proxy_buffering	on;	#proxy에서 보낸 값을 메모리에 임시 저장 설정
		}
		location ~ \.jsp$ {
			proxy_pass	http://cms-was;	#위에서 정의한 upstream의 이름을 여기에 사용
			proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
			proxy_connect_timeout 5s;     # 백엔드 연결 대기 최대 5초
			proxy_send_timeout 5s;       # 요청 전송 10초 제한
			proxy_read_timeout 15s;       # 응답 수신 30초 제한
			
			proxy_set_header	Proxy-Client-IP	$remote_addr;	#server에 전송할 header 세팅
			proxy_set_header X-Hash-Key	$remote_addr;
			proxy_set_header	session_user_id	$http_session_user_id;
			client_max_body_size	0;	#cli에서 전송하는 최대 요청 바이트 크기를 제한함[0은 무제한] <=> maxPostSize
			proxy_buffering	on;	#proxy에서 보낸 값을 메모리에 임시 저장 설정
		}
		location ~ \.xlsx$ {
			proxy_pass	http://cms-was;	#위에서 정의한 upstream의 이름을 여기에 사용
			proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
			proxy_connect_timeout 5s;     # 백엔드 연결 대기 최대 5초
			proxy_send_timeout 5s;       # 요청 전송 10초 제한
			proxy_read_timeout 15s;       # 응답 수신 30초 제한
			
			proxy_set_header	Proxy-Client-IP	$remote_addr;	#server에 전송할 header 세팅
			proxy_set_header X-Hash-Key	$remote_addr;
			proxy_set_header	session_user_id	$http_session_user_id;
			client_max_body_size	0;	#cli에서 전송하는 최대 요청 바이트 크기를 제한함[0은 무제한] <=> maxPostSize
			proxy_buffering	on;	#proxy에서 보낸 값을 메모리에 임시 저장 설정
		}
		location /FileUpload/upload.do$ {
			proxy_pass	http://cms-was;	#위에서 정의한 upstream의 이름을 여기에 사용
			proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
			proxy_connect_timeout 5s;     # 백엔드 연결 대기 최대 5초
			proxy_send_timeout 5s;       # 요청 전송 10초 제한
			proxy_read_timeout 15s;       # 응답 수신 30초 제한
			
			proxy_set_header	Proxy-Client-IP	$remote_addr;	#server에 전송할 header 세팅
			proxy_set_header X-Hash-Key	$remote_addr;
			proxy_set_header	session_user_id	$http_session_user_id;
			client_max_body_size	0;	#cli에서 전송하는 최대 요청 바이트 크기를 제한함[0은 무제한] <=> maxPostSize
			proxy_buffering	on;	#proxy에서 보낸 값을 메모리에 임시 저장 설정
		}
		location /FileDownLoad/checkFileExistGlobal.do$ {
			proxy_pass	http://cms-was;	#위에서 정의한 upstream의 이름을 여기에 사용
			proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
			proxy_connect_timeout 5s;     # 백엔드 연결 대기 최대 5초
			proxy_send_timeout 5s;       # 요청 전송 10초 제한
			proxy_read_timeout 15s;       # 응답 수신 30초 제한
			
			proxy_set_header	Proxy-Client-IP	$remote_addr;	#server에 전송할 header 세팅
			proxy_set_header X-Hash-Key	$remote_addr;
			proxy_set_header	session_user_id	$http_session_user_id;
			client_max_body_size	0;	#cli에서 전송하는 최대 요청 바이트 크기를 제한함[0은 무제한] <=> maxPostSize
			proxy_buffering	on;	#proxy에서 보낸 값을 메모리에 임시 저장 설정
		}
		location /KEYFRAME {
			alias //172.30.88.63/cifs2/TestFolder/KEYFRAME;
			#alias //172.30.88.63/cifs2/TestFolder/proxy;
			#alias //172.30.88.63/cifs/PROXY;
			autoindex on;  # 디렉토리 내 파일 목록 보기 활성화
			autoindex_exact_size off;  # 파일 크기를 정확히 표시하지 않음
			autoindex_localtime on;  # 파일 수정 시간을 로컬 시간으로 표시
		}
        error_page   500 502 503 504  /50x.html;
		
		location = /nginx_status {
			check_status;
		}
		
        location = /50x.html {
            root   html;
        }
    }
}
